/**
 * Output: 0 1 2 3 4
 * ES6 引入了新的变量名的声明关键字--let
 * 
 * let的特点:
 *  1. 不能重复命名(作用域(声明所在的作用域)), let声明的变量只在它的代卖块里面有作用, 块级作用域。
 *  2. let命名的变量或者函数, 不存在变量提升的效果。
 * 
 */

// for(let i = 0; i < 5; i++) {
//     setTimeout(function () {
//         console.log(i);
//     }, 1000);
// }

/**
 * Output: 5 5 5 5 5
 * 
 * 问题: 实现打印输出0, 1, 2, 3, 4 怎么实现
 * 闭包
 * 
 * 
 * 
 * 
 */
for(var i = 0; i < 5; i++) {
    setTimeout(() => {
        console.log(i);
    }, 1000);
}


/**
 * 变量i是用var声明的, 在全局范围内都有效, 所以全局范围内只有一个变量i,
 * 每一次循环, 变量i的值都会发生变化, 但是在循环内部, 我们对i进行了i+1的操作,
 * 外面的这个console.log(i), i指向全局的i。
 * 也就是说, 我在外面打印的这个i指向的都是同一个i, 
 */
// for(var i = 0; i < 5; i++) {
//     // ....
// }
// var i = 0;
// var i = 1;
// console.log(i); // 1 值被覆盖, 声明被销毁


// for(let i = 0; i < 5; i++) {
//     //...
// }


// console.log(i);



/**
 * 变量i是var声明的, 在全局范围内都有效, 在我的全局范围内只有一个变量i;
 * 每一次循环, 变量i的值都会发生变化;
 * 在循环内, 被赋值给arr的函数内部的console.log(i)中的i指向全局的i。
 * 
 * 
 * 换句话说, 所有数组arr的成员中的i指向的都是全局的i(5)(同一个i), 
 * 导致了console.log(i) 运行输出的是最后一轮的i值, 也就是5
 */
// var arr = [];
// for(var i = 0; i < 5; i++) {
//     arr[i] = function () {
//         console.log(i);
//     };
// }

// arr[3](); // 5


/**
 * 变量i是let声明的, 当前的i只在本轮循环有效。
 * 
 * 
 * 循环每走一次, i其实都是一个新的变量
 * 
 * 既然声明的是一个新的变量，那它怎么知道我上一个变量的值？
 * 
 * 这是因为JavaScript引擎内部会记住上一轮循环的值, 初始化这一轮的变量i, 就在上一轮循环的基础上进行计算。
 */
// var arr1 = [];
// for(let i = 0; i < 5; i++) {
//     arr1[i] = function () {
//         console.log(i);
//     };
// }

// arr1[3](); // 